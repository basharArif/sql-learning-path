# NoSQL Data Modeling: Design Patterns

**Level:** Intermediate  
**Time Estimate:** 30 minutes  
**Prerequisites:** Basic NoSQL concepts, CAP theorem, document databases.

## TL;DR
NoSQL data modeling focuses on access patterns rather than normalization. Design for how data is queried and updated, not just how it's stored. Use embedding, referencing, and specialized patterns based on your database type.

## Learning Objectives
By the end of this lesson, you'll be able to:
- Design NoSQL schemas based on access patterns
- Choose between embedding and referencing strategies
- Apply data modeling patterns for different NoSQL types
- Optimize schemas for performance and scalability

## Motivation & Real-World Scenario
Building a blog platform where you need to display articles with comments, author info, and tags. In SQL you'd normalize into separate tables, but in NoSQL you might embed comments and denormalize author data based on read patterns.

## Theory: NoSQL Data Modeling Principles

### Access Pattern Driven Design

**Traditional SQL Approach:**
- Normalize to eliminate redundancy
- Use joins for related data
- Optimize for storage efficiency

**NoSQL Approach:**
- Design for query patterns
- Denormalize for read performance
- Optimize for access frequency

**Key Question:** How will the data be accessed?

### Document Database Patterns

#### 1. Embedding (One-to-One/Few)
**Store related data together in single document**

```javascript
// User profile with embedded preferences
{
  "_id": ObjectId("..."),
  "username": "johndoe",
  "email": "john@example.com",
  "profile": {
    "firstName": "John",
    "lastName": "Doe",
    "bio": "Software developer",
    "avatar": "john.jpg"
  },
  "preferences": {
    "theme": "dark",
    "notifications": true,
    "language": "en"
  }
}
```

**When to Embed:**
- Data is always accessed together
- One-to-one or one-to-few relationships
- Atomic updates needed
- Document size stays reasonable (< 16MB)

#### 2. Referencing (One-to-Many/Many-to-Many)
**Store relationships via references**

```javascript
// Blog post with author reference
{
  "_id": ObjectId("post1"),
  "title": "NoSQL Best Practices",
  "content": "...",
  "author_id": ObjectId("user123"),
  "tags": ["nosql", "mongodb"],
  "published_at": ISODate("2023-01-01")
}

// Author document
{
  "_id": ObjectId("user123"),
  "name": "John Doe",
  "bio": "Database expert",
  "posts_count": 15
}
```

**When to Reference:**
- One-to-many relationships
- Data accessed independently
- Avoids data duplication
- Documents would be too large if embedded

#### 3. Bucket Pattern (Time Series/Sequential)
**Group related sequential data**

```javascript
// Sensor readings bucketed by hour
{
  "_id": ObjectId("..."),
  "sensor_id": "temp_sensor_001",
  "date": "2023-01-01",
  "hour": 10,
  "readings": [
    { "timestamp": "10:00", "value": 23.5 },
    { "timestamp": "10:15", "value": 24.1 },
    { "timestamp": "10:30", "value": 23.8 },
    { "timestamp": "10:45", "value": 24.3 }
  ],
  "min_value": 23.5,
  "max_value": 24.3,
  "avg_value": 23.9
}
```

**When to Use:**
- Time series data
- Sequential data access
- Pre-aggregated values needed
- Bounded data sets

### Key-Value Store Patterns

#### 1. Simple Key-Value
```
Key: "user:123:profile"
Value: {"name": "John", "email": "john@example.com"}

Key: "user:123:preferences"
Value: {"theme": "dark", "lang": "en"}
```

#### 2. Namespaced Keys
```
user:123:profile → User data
user:123:posts → User's posts
user:123:followers → Follower list
product:456:reviews → Product reviews
```

#### 3. Composite Keys
```
session:user123:20230101 → Session data
cache:product:456:views → View counter
lock:resource:789 → Distributed lock
```

### Column-Family Store Patterns

#### 1. Wide Rows (Cassandra)
```sql
-- User timeline (wide row)
CREATE TABLE user_timeline (
  user_id uuid,
  tweet_id uuid,
  tweet_text text,
  created_at timestamp,
  PRIMARY KEY (user_id, created_at)
) WITH CLUSTERING ORDER BY (created_at DESC);
```

#### 2. Time Series Pattern
```sql
-- Sensor data
CREATE TABLE sensor_readings (
  sensor_id text,
  date text,
  time timestamp,
  value double,
  PRIMARY KEY ((sensor_id, date), time)
);
```

### Graph Database Patterns

#### 1. Property Graph Model
```
Nodes: User, Post, Comment
Relationships: AUTHORED, COMMENTED_ON, LIKES

(User:John)-[:AUTHORED]->(Post:HelloWorld)
(User:Jane)-[:COMMENTED_ON]->(Post:HelloWorld)
(User:Jane)-[:LIKES]->(Post:HelloWorld)
```

#### 2. Common Graph Patterns
- **Social Networks**: Users connected by friendships
- **Recommendation Engines**: Products connected by user preferences
- **Knowledge Graphs**: Entities connected by relationships
- **Access Control**: Resources connected by permissions

## Schema Design Process

### Step 1: Identify Access Patterns
```
Common Queries for Blog Platform:
├── Get article with comments and author → Embed comments, reference author
├── Get user's all articles → Reference articles from user
├── Get articles by tag → Index tags, use aggregation
├── Get recent articles → Time-based indexing
└── Search articles → Full-text search index
```

### Step 2: Choose Database Type
```
Access Pattern → Database Type

├── Complex relationships → Graph Database
├── Time series data → Time Series DB
├── Full-text search → Search Engine
├── Key-value lookups → Key-Value Store
├── Flexible documents → Document DB
└── Wide column analytics → Column-Family Store
```

### Step 3: Design Schema
```
For each access pattern:
├── Choose embedding vs referencing
├── Plan indexes for queries
├── Consider data growth
├── Design for concurrent access
└── Plan for data migration
```

### Step 4: Validate Design
```
Test against requirements:
├── Query performance acceptable?
├── Data consistency appropriate?
├── Scalability requirements met?
├── Maintenance overhead reasonable?
└── Future changes supported?
```

## Common Anti-Patterns

### 1. SQL Thinking in NoSQL
```javascript
// Anti-pattern: Normalized like SQL
{
  "order_id": 123,
  "customer_id": 456,  // Foreign key
  "product_ids": [789, 012]  // Foreign keys
}

// Better: Embed what you query together
{
  "order_id": 123,
  "customer": {
    "id": 456,
    "name": "John Doe",
    "email": "john@example.com"
  },
  "items": [
    { "product_id": 789, "name": "Widget", "price": 29.99 },
    { "product_id": 012, "name": "Gadget", "price": 49.99 }
  ]
}
```

### 2. Over-Embedding
```javascript
// Anti-pattern: Embed everything
{
  "user_id": 123,
  "name": "John",
  "posts": [/* 1000+ posts embedded */],
  "comments": [/* 5000+ comments embedded */],
  "likes": [/* 10000+ likes embedded */]
}

// Better: Reference and paginate
{
  "user_id": 123,
  "name": "John",
  "recent_posts": [/* Last 10 posts */],
  "stats": {
    "total_posts": 1000,
    "total_comments": 5000,
    "total_likes": 10000
  }
}
```

### 3. Ignoring Data Growth
```javascript
// Anti-pattern: Unbounded arrays
{
  "user_id": 123,
  "activity_log": [/* Grows indefinitely */]
}

// Better: Use bucketing or archiving
{
  "user_id": 123,
  "activity_2023": [...],
  "activity_2024": [...]
}
```

## Performance Optimization

### Indexing Strategies
```javascript
// Compound index for common queries
db.users.createIndex({ "department": 1, "salary": -1 })

// Partial index for filtered queries
db.users.createIndex(
  { "status": 1 },
  { partialFilterExpression: { "status": "active" } }
)

// Text index for search
db.articles.createIndex({ "title": "text", "content": "text" })
```

### Read/Write Optimization
- **Read-Heavy**: Embed frequently accessed data
- **Write-Heavy**: Reference to avoid update conflicts
- **Mixed Load**: Balance embedding and referencing
- **Analytics**: Use aggregation pipelines

## Migration Strategies

### From SQL to NoSQL
1. **Identify Access Patterns**: Analyze current queries
2. **Choose Target Schema**: Design for NoSQL patterns
3. **Plan Data Transformation**: Handle relationships and constraints
4. **Implement Migration**: ETL processes with validation
5. **Update Application**: New data access patterns

### Schema Evolution
```javascript
// Version field for schema changes
{
  "schema_version": 2,
  "user_id": 123,
  "name": "John",
  // New fields added in v2
  "preferences": { "theme": "dark" }
}
```

## Quick Checklist / Cheatsheet

**Data Modeling Decisions:**
- **Embed**: Data always accessed together, small size, atomic updates
- **Reference**: Independent access, large data, one-to-many relationships
- **Bucket**: Time series, sequential data, bounded collections

**Database Selection:**
- **Document DB**: Flexible schemas, complex objects, aggregation
- **Key-Value**: Simple lookups, caching, sessions
- **Column-Family**: Time series, analytics, wide rows
- **Graph DB**: Relationships, traversals, recommendations

**Performance Considerations:**
- Index frequently queried fields
- Avoid unbounded array growth
- Plan for data distribution
- Monitor query performance

## Exercises

1. **Easy**: Design a schema for a simple e-commerce product catalog. Decide what to embed vs reference for products, categories, and reviews.

2. **Medium**: For a social media platform, design schemas for users, posts, comments, and likes. Consider different access patterns like user feeds, post details, and trending content.

3. **Hard**: You're building a multi-tenant SaaS application. Design a NoSQL schema that supports tenant isolation, efficient queries per tenant, and scalable growth. Consider using multiple database types if appropriate.