# ACID vs BASE: Consistency Models

**Level:** Intermediate  
**Time Estimate:** 20 minutes  
**Prerequisites:** Basic understanding of databases and CAP theorem.

## TL;DR
ACID ensures strong consistency and reliability for traditional applications, while BASE enables high availability and scalability for modern distributed systems. Understanding both models helps you choose the right approach for your data requirements.

## Learning Objectives
By the end of this lesson, you'll be able to:
- Explain ACID and BASE consistency models
- Understand trade-offs between consistency and availability
- Apply appropriate consistency models to different scenarios
- Design systems that balance reliability and performance

## Motivation & Real-World Scenario
Building a global banking application where account transfers must be perfectly consistent versus a social media platform where slight delays in feed updates are acceptable. Different consistency models serve different business needs.

## Theory: ACID vs BASE

### ACID: Traditional Consistency Model

**ACID** = **A**tomicity, **C**onsistency, **I**solation, **D**urability

**Guarantees:**
- **Atomicity**: All operations in a transaction succeed or fail together
- **Consistency**: Database remains in valid state before and after transaction
- **Isolation**: Concurrent transactions don't interfere with each other
- **Durability**: Committed changes survive system failures

**Visual Representation:**
```
ACID Transaction Flow
├── Begin Transaction
├── Execute Operations
│   ├── Operation 1 ✓
│   ├── Operation 2 ✓
│   └── Operation 3 ✓
├── All Succeed → Commit
└── Any Fail → Rollback (Atomicity)
```

**Databases:** Traditional RDBMS (PostgreSQL, MySQL, Oracle)

### BASE: Modern Scalability Model

**BASE** = **B**asically **A**vailable, **S**oft state, **E**ventual consistency

**Characteristics:**
- **Basically Available**: System remains operational despite failures
- **Soft State**: State may change over time (even without input)
- **Eventual Consistency**: System will become consistent over time

**Visual Representation:**
```
BASE System Behavior
├── Immediate Response (Available)
├── Temporary Inconsistency (Soft State)
├── Background Synchronization
└── Eventual Consistency (Converged State)
```

**Databases:** Most NoSQL systems (MongoDB, Cassandra, DynamoDB)

## Detailed Comparison

### Atomicity vs Availability

**ACID Atomicity:**
```sql
-- Bank transfer: $100 from Account A to Account B
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 'A';
UPDATE accounts SET balance = balance + 100 WHERE id = 'B';
COMMIT;
-- Either both updates succeed or both fail
```

**BASE Availability:**
```javascript
// Social media like
db.posts.updateOne(
  { _id: postId },
  { $inc: { likes: 1 } }
);
// System stays available even if some nodes are inconsistent
```

### Consistency Models

**Strong Consistency (ACID):**
- All reads return most recent write
- Simplifies application logic
- Performance cost for coordination

**Eventual Consistency (BASE):**
- Reads may return stale data temporarily
- High performance and availability
- Application handles conflicts

### Isolation Levels

**ACID Isolation Levels:**
- **Serializable**: Complete isolation, like single-threaded execution
- **Repeatable Read**: Same data returned for same query in transaction
- **Read Committed**: Only committed data visible
- **Read Uncommitted**: Uncommitted changes visible

**BASE Isolation:**
- **Read Your Writes**: User sees their own changes immediately
- **Monotonic Reads**: Once you see a value, you won't see older values
- **Causal Consistency**: Causally related operations appear in order

## Practical Implications

### When ACID is Essential

**Financial Systems:**
- Bank transfers require atomicity
- Account balances must be consistent
- Double-spending prevention critical

**E-commerce:**
- Inventory management
- Order processing
- Payment transactions

**Enterprise Applications:**
- ERP systems
- CRM databases
- Regulatory compliance

### When BASE is Appropriate

**Social Media:**
- Like counts can be eventually consistent
- Feed updates don't need instant visibility
- High availability more important than perfect consistency

**Content Management:**
- Article views and comments
- User-generated content
- Search indexes

**IoT & Analytics:**
- Sensor data collection
- Log aggregation
- Real-time dashboards

## Conflict Resolution Strategies

### Last Write Wins (LWW)
```javascript
// Simple resolution: Latest timestamp wins
{
  "_id": "user123",
  "name": "John",
  "last_modified": "2023-01-01T10:00:00Z",
  "version": 1
}
// Conflicting update with newer timestamp takes precedence
```

### Application-Level Resolution
**Merge conflicts using business logic rules:**
- Version-based conflict resolution
- Business rule prioritization
- Manual conflict resolution workflows
- Event sourcing for audit trails

### Operational Transformation
**Transform operations to maintain consistency:**
- Concurrent operations are transformed to preserve intent
- Used in collaborative editing systems
- Mathematical approach to conflict resolution
- Ensures all replicas converge to same state

## Real-World Examples

### Banking: ACID Required
```
Transfer $100: Account A ($500) → Account B ($300)
├── ACID: Either A=$400, B=$400 or A=$500, B=$300
└── BASE: Could temporarily show A=$400, B=$300 (inconsistent)
```

### Social Media: BASE Acceptable
```
User likes post: Like count = 42
├── ACID: All users see 43 immediately
└── BASE: Some users see 42, others see 43 (eventually consistent)
```

### E-commerce Cart: Hybrid Approach
```
Add to cart: Use BASE for availability
Checkout: Use ACID for payment processing
```

## Performance Trade-offs

### ACID Performance Characteristics
- **Reads**: Fast (no coordination needed)
- **Writes**: Slower (coordination overhead)
- **Scaling**: Vertical (bigger servers)
- **Latency**: Predictable but higher

### BASE Performance Characteristics
- **Reads**: Fast (local node access)
- **Writes**: Fast (minimal coordination)
- **Scaling**: Horizontal (many servers)
- **Latency**: Low and predictable

## Choosing the Right Model

### Decision Framework
```
Data Requirements → Consistency Model

├── Financial transactions → ACID
├── User-generated content → BASE
├── Configuration data → ACID
├── Session data → BASE
├── Analytics data → BASE
├── Master data → ACID
└── Event data → BASE
```

### Hybrid Approaches
- **Within Application**: Different consistency levels for different data
- **CQRS Pattern**: Separate read and write models
- **Saga Pattern**: Distributed transactions with compensation

## Quick Checklist / Cheatsheet

**Choose ACID when:**
- Data accuracy is more important than availability
- Complex transactions span multiple entities
- Regulatory compliance requires strong consistency
- Your domain demands predictable behavior

**Choose BASE when:**
- High availability is critical
- Temporary inconsistencies are acceptable
- You need massive horizontal scalability
- Performance is more important than immediate consistency

**Consider Hybrid when:**
- Different parts of your system have different requirements
- You can isolate consistency boundaries
- Application complexity is manageable

## Exercises

1. **Easy**: Explain why a bank transfer must use ACID while a social media like can use BASE.

2. **Medium**: Design a system for an online auction site. Which parts should use ACID and which can use BASE? Explain your reasoning.

3. **Hard**: You're building a ride-sharing app. Design the data architecture considering driver locations (real-time), ride bookings (consistent), payment processing (reliable), and user profiles (flexible). Specify consistency models for each component.